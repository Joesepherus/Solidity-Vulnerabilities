<h2>Delegate Call Exploit</h2>

<p>
Delegatecall is identical to a message call except that the code at the target address is executed in the context of the calling contract and the values of msg.sender and msg.value are not changed.
</p>
<p>
Delegatecall has been extremely useful because it serves as the foundation for implementing libraries and modularizing code. Delegatecall also allows a contract to dynamically load code from a different address, however it introduces vulnerabilities because a contract essentially allows anyone to do anything they want with their state resulting in unexpected code execution.
</p>

<blockquote>
The most widely adopted technique to upgrade contracts is utilizing a proxy contract using delegate call.
</blockquote>
<br>
<p>
For example if you have V1 contract with variables x and owner and then you upgrade to V2 and add variable y but the proxy contract just has x and owner and you then try to change y, it will then change owner in the proxy contract to the value of y. And now an attacker can change the owner to any value and be in complete control of all the contracts.
</p>

<p>
Even though there are certain problems associated with delegatecall, it is very often used in many contracts such as OpenZeppelin, Solidity libraries, EIP2535 diamonds, and many more.
</p>

<h3>Call</h3>
<p>
It allows you to call the code of the callee contract from the caller with the storage context of the callee.
</p>

<h3>DelegateCall</h3>
<p>
It allows you to call the code of the callee contract from the caller with the storage context of the caller.
</p>


<blockquote>One use case of call is the transfer of Ether to a contract, and it passes all the gas to the receiving function, while the use cases of the delegatecall are when a contract invokes a library with public functions or uses a proxy contract to write smart upgradeable contracts.</blockquote>


<h3>How to Prevent Delegate Call Exploit?</h3>
<ul>
<li>
If possible, avoid using additional storage variables or go stateless in the upgraded contract â€“ V2.
</li>
<li>
Mirror the storage layout in V2, in other words, the contract calling delegatecall and the contract being called must have the same storage layout.
</li>
<li>
By implementing unstructured storage in proxy with the help of assembly code as in OpenZeppelins proxy and not having any storage variables in proxy apart from the logical contract address.
</li>
</ul>
<a href="https://blog.finxter.com/delegatecall-or-storage-collision-attack-on-smart-contracts/" target="_blank" rel="noopener noreferrer">link</a>
