<p>In Solidity development, where smart contracts execute on the blockchain, coding standards are particularly crucial. The decentralized nature of blockchain applications makes it difficult to modify or fix deployed contracts.</p><p></p><h3>Why we need to follow Coding Standards?</h3><ul><li><p>Improved Collaboration</p></li><li><p>Enhanced Readability</p></li><li><p>Reduced Maintenance Effort</p></li><li><p>Code Reusability</p></li><li><p>Security</p></li></ul><p></p><p>So basically it's about making sure the code is readable for even a junior and even someone who is not familiar with the specific project and also for lowering the amount of work it is to change something and maintain the project overall. And ofocurse can't forget about security, that's what writting good contracts is all about. <strong>SECURITY</strong></p><p></p><h3>Naming Conventions</h3><p><strong>Contracts</strong>: Use <strong>PascalCase</strong> (capitalized words without spaces) for contract names. For example, <strong>MyContract</strong>.</p><p><strong>Functions</strong>: Use <strong>camelCase</strong> (capitalizing the first letter of each word except the first) for function names. For example, <strong>myFunction</strong>.</p><p><strong>Variables</strong>: Use <strong>camelCase</strong> for variable names. Avoid using single-letter variable names unless they are used as loop counters.</p><p><strong>Constants</strong>: Use <strong>uppercase</strong> with underscores for constant variable names. For example, <strong>MY_CONSTANT</strong>.</p><p></p><h3>Writing Efficient Code to Minimize Gas Costs</h3><p><strong>Avoid unnecessary computations</strong>: Carefully analyze your code and remove any calculations that are not required. This includes redundant loops, unnecessary conversions, and excessive data operations.</p><p></p><p><strong>Use efficient data structures</strong>: Choose the appropriate data structures for your specific use case. For example, using arrays instead of mappings can be more efficient in certain situations.</p><p></p><p><strong>Minimize storage operations</strong>: Storage operations are more expensive than memory operations. Reduce the number of read and write operations to storage variables by leveraging memory variables wherever possible.</p><p></p><p><strong>Reuse code</strong>: Encapsulate reusable functionality in separate functions or libraries. By reusing code, you can reduce duplicate operations and save gas.</p><p></p><h3>Avoiding Common Gas-Wasting Patterns</h3><p><strong>Excessive use of loops</strong>: Loops can consume a significant amount of gas, especially if they iterate over large data sets. Consider alternative approaches, such as using mappings or indexing mechanisms, to avoid gas inefficiency.</p><p></p><p><strong>Unbounded iterations</strong>: Be cautious when using loops with undetermined or unbounded iterations. Always ensure that loops have a clear termination condition to prevent potential gas exhaustion.</p><p></p><p><strong>Large data storage</strong>: Storing excessive data on the blockchain can result in higher gas costs. Evaluate whether all the data needs to be stored on-chain or if off-chain storage solutions can be utilized.</p><p>Inefficient algorithms: Choose algorithms that are optimized for gas efficiency. For example, using a linear search when a binary search is applicable can lead to unnecessary gas consumption.</p><p></p><blockquote><p>Optimizing gas usage is essential for smart contract developers to ensure cost-effective and efficient execution on the Ethereum blockchain.</p></blockquote><p></p><h3>Best Practices for Secure Solidity Development</h3><p><strong>Access Control</strong>: Implement robust access control mechanisms to restrict unauthorized access to contract functions and data. Use modifiers and access control patterns to define permission levels and enforce proper authorization.</p><p></p><p><strong>Input Validation</strong>: Validate and sanitize user input to prevent malicious code execution and ensure the integrity of the contract. Use appropriate data validation techniques to validate user input and prevent potential vulnerabilities such as overflow or underflow.</p><p></p><p><strong>Secure External Calls</strong>: Exercise caution when interacting with external contracts or external data sources. Implement security measures such as checks-effects-interactions pattern to prevent reentrancy attacks and ensure secure interactions.</p><p></p><p><strong>Secure Smart Contract Upgradeability</strong>: Consider implementing upgradeable smart contracts to address bugs or add new features without compromising the integrity of the contract. Follow best practices for ensuring upgradability in Solidity, such as using proxy contracts and upgradeable storage patterns.</p><p></p><p><strong>Code Auditing and Testing</strong>: Conduct thorough code audits and extensive testing to identify and fix vulnerabilities. Perform security audits by external experts to obtain an independent assessment of the contract’s security.</p><p></p><h3>Avoiding Common Security Vulnerabilities</h3><p><strong>Reentrancy</strong>: Prevent reentrancy attacks by following best practices such as using the checks-effects-interactions pattern, ensuring proper state management, and carefully handling external calls.</p><p></p><p><strong>Integer Overflow/Underflow</strong>: Implement checks and validations to prevent integer overflow/underflow vulnerabilities. Utilize SafeMath libraries or similar techniques to perform arithmetic operations securely.</p><p></p><p><strong>Unchecked External Calls</strong>: Exercise caution when making external calls to other contracts. Validate and verify the integrity of the external contract before interacting with it.</p><p></p><p><strong>Denial of Service</strong>: Avoid potential denial of service (DoS) attacks by carefully managing gas usage, implementing gas limits, and avoiding loops with unpredictable iterations.</p><p></p><p><strong>Front-Running</strong>: Protect against front-running attacks by implementing appropriate mechanisms such as using cryptographic solutions or randomization techniques.</p><p></p><h3>Include SPDX-License-Identifier</h3><p></p><h3>You should fix the Solidity version to the compiler you are using.</h3><p>Dont use this</p><pre><code>pragma solidity ^0.8.0;</code></pre><p>Use this</p><pre><code>pragma solidity 0.8.21;</code></pre><p><br>Explicitly set the library version in the import statement</p><p></p><h3>Use named imports instead of importing the entire namespace</h3><p>Instead of doing this</p><pre><code>import "@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol";</code></pre><p>Do this</p><pre><code>import {ERC20} from "@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol";</code></pre><p></p><h3>Delete unused imports</h3><p></p><h3>Apply contract-level natspec</h3><p>An example natspec for a contract is shown below.</p><pre><code>/// @title Liquidity token for Foo protocol
/// @author Foo Incorporated
/// @notice Notes for non-technical readers/
/// @dev Notes for people who understand Solidity
contract LiquidityToken {

}</code></pre><p></p><h3>Lay out the contract structure per the style guide</h3><p>They should be ordered as follows: type declarations, state variables, events, errors, modifiers, receive and fallback functions (if applicable), external functions, public functions, internal functions, and private functions.</p><p>Within those groups, the payable functions go on top, then non-payable, then view, then pure.</p><p></p><h3>Replace magic numbers with constants</h3><p>Generally, numbers should be written as a constant at the top of the contract.</p><h3><br>If numbers are used to measure ether or time, use the solidity keywords</h3><p>Instead of writing</p><pre><code>uint256 secondsPerDay = 60 * 60 * 24;</code></pre><p>do</p><pre><code>1 days;</code></pre><p>instead of writing</p><pre><code>require(msg.value == 10**18 / 10, "must send 0.1 ether");</code></pre><p>do</p><pre><code>require(msg.value == 0.1 ether, "must send 0.1 ether");</code></pre><p></p><h3>Use underscores to make large numbers more readable</h3><p>Instead of doing this</p><pre><code>uint256 private constant BASIS_POINTS_DENOMINATOR = 10000</code></pre><p>do this</p><pre><code>uint256 private constant BASIS_POINTS_DENOMINATOR = 10_000</code></pre><p></p><h3>Remove the virtual modifier from functions that will not be overridden</h3><p>The virtual modifier means “overridable by a child contract.” But if you know you will not be overriding the function (because you are the deployer), then this modifier is superfluous. Just delete it.</p><h3><br>Put function modifiers in the correct order visibility, mutability, virtual, override custom modifier</h3><p></p><pre><code>// visibility (payability), [virtual], [override], [custom]
function foo() public payable onlyAdmin {

}

function bar() internal view virtual override onlyAdmin {

}</code></pre><p></p><h3>Use natspec properly for functions</h3><p>The rules are similar to the contract natspec, except that we also specify params based on the function arguments and what gets returned.</p><pre><code>/// @notice Deposit ERC20 tokens
/// @dev emits a Deposit event
/// @dev reverts if the token is not allowlisted
/// @dev reverts if the contract is not approved by the ERC20
/// @param token The address of the ERC20 token to be deposited
/// @param amount The amount of ERC20 tokens to deposit
/// @returns the amount of liquidity tokens the user receives
function deposit(address token, uint256 amount) public returns (uint256) {

}

// If the contract inherits functions, you can also inherit their natspec
/// @inheritdoc Lendable
function calculateAccumulatedInterest(address token, uint256 since) public override view returns (uint256 interest) {

} </code></pre><p></p><p>For the dev parameters, it’s good to notify what kind of state changes it can do, for example emitting an event, sending ether, selfdestructing, etc.</p><p>The notice and param natspec are read by Etherscan.</p><p></p><h3>Remove commented out code</h3><p></p><h3>Think carefully about variable names</h3><p></p><h2>Additional Tricks for organizing large codebases</h2><ul><li><p>If you have a lot of storage variables, you can define all the storage variables in a single contract, then inherit from that contract to gain access to those storage variables.</p></li><li><p>If your functions require a significant amount of parameters, use a struct to pass the information around.</p></li><li><p>If you need a lot of imports, you can import all the files and types into one solidity file, then import that file (you would need to intentionally break the rule about named imports).</p></li><li><p>Use libraries to group functions of the same category together and make files smaller.</p></li></ul><p><a target="_blank" rel="noopener noreferrer" href="https://www.rareskills.io/post/solidity-style-guide">link</a><a target="_blank" rel="noopener noreferrer" href="https://www.soliditylibraries.com/best-practices/solidity-coding-standards-ensuring-clean/">link</a></p>